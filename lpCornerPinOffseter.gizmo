#! /Volumes/Infra/packages/software/nuke/13.2.8-0/platform-linux/arch-x86_64/src/libnuke-13.2.8.so -nx
version 13.2 v8
Group {
name CornerPinOffseter
inputs 0
tile_color 0xff5f00ff
note_font "Bitstream Vera Sans Bold"
addUserKnob {20 CornerPinOffsetter}
addUserKnob {85 CPSelector l Selector M {"Here CornerPin nodes will appear!"}}
addUserKnob {22 CPSearch l <b>Search -STARTLINE T "import nuke\n\n# NODE SEARCH\n#################################################\n\ndef searchNodes(type):\n\n    nodeList = \[]\n        \n    for node in nuke.allNodes():\n        nodeClass = node.Class()\n    \n        if nodeClass.__contains__(type):\n            # node.setSelected(True)\n            nodeList.append(node.knob('name').getValue())\n    \n    nodeList.sort()\n    return nodeList\n#################################################\n#################################################\n\nthis_node = nuke.thisNode()\n\nwith nuke.root():\n    nodeList = searchNodes('CornerPin2D')\n    if not nodeList:\n        nodeList.append(\"Here CornerPin nodes will appear!\")\n        nuke.message(\"Couldn't Load CornerPins!<br>List was empty :(\")\n        this_node.knob('CPSelector').setValues(nodeList)\n        \n    else:\n        nuke.message(\"CornerPins Loaded!\")\n        this_node.knob('CPSelector').setValues(nodeList)"}
addUserKnob {22 CPBake l <b>Bake -STARTLINE T "import nuke\n\ndef bakeCurve( curve, first, last, inc ):\n    '''bake an expresison curve into a keyframes curve'''\n    for f in range( first, last, inc ):\n        curve.setKey( f, curve.evaluate( f ) )\n    curve.setExpression( 'curve' )\n\n####################################################\ndef getCurves( knob, views ):\n    '''return a list of all animation curves found in the given knob'''\n    curves = \[]\n    for v in views:\n        curves.extend( knob.animations( v ) )\n    return curves\n\n####################################################\ndef bakeExpressionKnobs( node, first, last, inc, views ):  \n    '''bake all knobs in node that carry expressions'''\n    # GET ALL KNOBS WITH EXPRESSIONS IN THEM\n    expKnobs = \[ k for k in node.knobs().values() if k.hasExpression() ]\n\n    # GET ALL CURVES INSIDE THAT KNOB INCLUDING SPLIT FIELDS AND VIEWS\n    allCurves = \[]\n    for k in expKnobs:\n        allCurves += getCurves( k, views )\n\n    # BAKE ALL CURVES\n    for c in allCurves:\n        bakeCurve( c, first, last, inc )\n\n####################################################\ndef bakeDependentNodes():\n    '''Add this to onUserDestroy callback - not yet implemented'''\n    parentNode = nuke.thisNode() # THIS IS GIVEN TO US BY THE CALLBACK, i.e. WHEN A NODE IS DELETED - WELL, NOT YET\n    depNodes  = parentNode.dependent( nuke.EXPRESSIONS )\n    \n    ret = nuke.getFramesAndViews( 'bake curves in dependent nodes?', '%s-%s' % (parentNode.firstFrame(), parentNode.lastFrame()) )\n    if not ret:\n        return\n    fRange = nuke.FrameRange( ret\[0] )\n    views = ret\[1]\n\n    for n in depNodes:\n        bakeExpressionKnobs( n, fRange.first(), fRange.last(), fRange.increment(), views )\n        \n\n####################################################\ndef bakeSelectedNodes():\n    '''bake selected nodes' knobs that carry expressions'''\n    ret = nuke.getFramesAndViews( 'bake curves in selected nodes?', '%s-%s' % (nuke.root().firstFrame(), nuke.root().lastFrame()) )\n    if not ret:\n        return\n    fRange = nuke.FrameRange( ret\[0] )\n    views = ret\[1]\n\n    for n in nuke.selectedNodes():\n        bakeExpressionKnobs( n, fRange.first(), fRange.last(), fRange.increment(), views )\n\n\n####################################################\ndef bakeNode(node):\n    '''bake selected nodes' knobs that carry expressions'''\n    ret = nuke.getFramesAndViews( 'bake curves in selected nodes?', '%s-%s' % (nuke.root().firstFrame(), nuke.root().lastFrame()) )\n    if not ret:\n        return\n    fRange = nuke.FrameRange( ret\[0] )\n    views = ret\[1]\n\n    bakeExpressionKnobs( node, fRange.first(), fRange.last(), fRange.increment(), views )\n\n\n\n###############################################################\n###############################################################\n\nnode = nuke.thisNode()\ncornerpin = nuke.toNode(nuke.toNode(node.knob('CPSelector').value()).name())\nbakeNode(cornerpin)"}
addUserKnob {22 CPLink l "<b>Bake and Link" -STARTLINE T "import nuke\n\ndef bakeCurve( curve, first, last, inc ):\n    '''bake an expresison curve into a keyframes curve'''\n    for f in range( first, last, inc ):\n        curve.setKey( f, curve.evaluate( f ) )\n    curve.setExpression( 'curve' )\n\n####################################################\ndef getCurves( knob, views ):\n    '''return a list of all animation curves found in the given knob'''\n    curves = \[]\n    for v in views:\n        curves.extend( knob.animations( v ) )\n    return curves\n\n####################################################\ndef bakeExpressionKnobs( node, first, last, inc, views ):  \n    '''bake all knobs in node that carry expressions'''\n    # GET ALL KNOBS WITH EXPRESSIONS IN THEM\n    expKnobs = \[ k for k in node.knobs().values() if k.hasExpression() ]\n\n    # GET ALL CURVES INSIDE THAT KNOB INCLUDING SPLIT FIELDS AND VIEWS\n    allCurves = \[]\n    for k in expKnobs:\n        allCurves += getCurves( k, views )\n\n    # BAKE ALL CURVES\n    for c in allCurves:\n        bakeCurve( c, first, last, inc )\n\n####################################################\ndef bakeDependentNodes():\n    '''Add this to onUserDestroy callback - not yet implemented'''\n    parentNode = nuke.thisNode() # THIS IS GIVEN TO US BY THE CALLBACK, i.e. WHEN A NODE IS DELETED - WELL, NOT YET\n    depNodes  = parentNode.dependent( nuke.EXPRESSIONS )\n    \n    ret = nuke.getFramesAndViews( 'bake curves in dependent nodes?', '%s-%s' % (parentNode.firstFrame(), parentNode.lastFrame()) )\n    if not ret:\n        return\n    fRange = nuke.FrameRange( ret\[0] )\n    views = ret\[1]\n\n    for n in depNodes:\n        bakeExpressionKnobs( n, fRange.first(), fRange.last(), fRange.increment(), views )\n        \n\n####################################################\ndef bakeSelectedNodes():\n    '''bake selected nodes' knobs that carry expressions'''\n    ret = nuke.getFramesAndViews( 'bake curves in selected nodes?', '%s-%s' % (nuke.root().firstFrame(), nuke.root().lastFrame()) )\n    if not ret:\n        return\n    fRange = nuke.FrameRange( ret\[0] )\n    views = ret\[1]\n\n    for n in nuke.selectedNodes():\n        bakeExpressionKnobs( n, fRange.first(), fRange.last(), fRange.increment(), views )\n\n\n####################################################\ndef bakeNode(node):\n    '''bake selected nodes' knobs that carry expressions'''\n    ret = nuke.getFramesAndViews( 'bake curves in selected nodes?', '%s-%s' % (nuke.root().firstFrame(), nuke.root().lastFrame()) )\n    if not ret:\n        return\n    fRange = nuke.FrameRange( ret\[0] )\n    views = ret\[1]\n\n    bakeExpressionKnobs( node, fRange.first(), fRange.last(), fRange.increment(), views )\n\n\n\n###############################################################\n###############################################################\n\nnode = nuke.thisNode()\ncornerpin = nuke.toNode(nuke.toNode(node.knob('CPSelector').value()).name())\nbakeNode(cornerpin)\n\ncornerpinKnobs = \['to1', 'to2', 'to3', 'to4', 'from1', 'from2', 'from3', 'from4']\n# \['to1_offset', 'to2_offset', 'to3_offset', 'to4_offset', from1_offset', 'from2_offset', 'from3_offset', 'from4_offset']\n\nfor knob in cornerpinKnobs:\n\n    cornerpin.knob(knob).setExpression(\"curve + \" + str(node.name()) + \".\" + knob + \"_offset\")\n    # this + CornerPinOffseter1.to1_offset"}
addUserKnob {22 CPUnlink l <b>Unlink -STARTLINE T "###############################################################\n###############################################################\n\nnode = nuke.thisNode()\ncornerpin = nuke.toNode(nuke.toNode(node.knob('CPSelector').value()).name())\n\ncornerpinKnobs = \['to1', 'to2', 'to3', 'to4', 'from1', 'from2', 'from3', 'from4']\n# \['to1_offset', 'to2_offset', 'to3_offset', 'to4_offset', from1_offset', 'from2_offset', 'from3_offset', 'from4_offset']\n\nfor knob in cornerpinKnobs:\n\n    cornerpin.knob(knob).setExpression(\"curve\")\n    # this + CornerPinOffseter1.to1_offset"}
addUserKnob {26 SelectorSeparator l "" +STARTLINE}
addUserKnob {20 CPTab l "" +STARTLINE n -2}
addUserKnob {20 To}
addUserKnob {12 to1_offset}
addUserKnob {12 to2_offset}
addUserKnob {12 to3_offset}
addUserKnob {12 to4_offset}
addUserKnob {20 From}
addUserKnob {12 from1_offset}
addUserKnob {12 from2_offset}
addUserKnob {12 from3_offset}
addUserKnob {12 from4_offset}
addUserKnob {20 "" n -3}
addUserKnob {26 kronos_nameSeparator l "" +STARTLINE}
addUserKnob {26 nodeName l "" +STARTLINE T " <b>lpCornerPinOffsetter v1.0</b>"}
addUserKnob {26 copyName l "" +STARTLINE T "David Lozano Pascual Â©"}
}
Output {
 inputs 0
 name Output1
 selected true
 xpos 0
 ypos 300
}
end_group
